# 数组

```js
 var arr = [1,11,111]
 delete arr[2] // arr 为[1, 11, empty]
 arr.length // 3
 // 使用delete运算符可以讲单元从数组中删除，但是请注意，单元删除后，数组的length属性并不会发生变化

var arr2 = [1,11,111,1111]
arr2['13'] = 42
arr2.length // 14
// 如果字符串健值能够被强制类型转换为十进制数组的话，他就会被当作数字索引来处理

/**
 * 在数组中加入字符串健值/属性并不是一个好主意，建议使用对象来存放健值/属性值，用数组来存放数字索引值
 */
```

# 类数组

```js
// 有时需要将类数组转化成真正的数组，例如一些DOM查询操作回返回dom元素列表，它们并非真正意义上的数组，但十分类似。另一个例子是通过arguments对象（类数组）将函数的参数当作列表来访问（从ES6开始已废止）

// 工具函数 slice() 经常用于这类转换:
function likeArr() {
  // arguments 顺着数组原型上去借调slice的方法【复制数组】
  var arr = Array.prototype.slice.call(arguments)
  return arr
}

likeArr('foo','bar','baz') // ['foo', 'bar', 'baz']

// ES6的内置工具函数 Array.from() 也能实现同样的功能
function es6LikeArr() {
  var arr = Array.from(arguments)
  return arr
}
es6LikeArr('foo','bar','baz') // ['foo', 'bar', 'baz']

```

# 字符串

```js
// 字符串经常被当成字符数组。字符串的内部实现究竟有没有使用数组并不好说，但js中的字符和字符数组并不是一回事，最多只是看上去相似而已。比如有 indexof 和 concat 方法

// js中字符串是不可变的，而数组是可变的。
var a = 'foo'
var b = ['f','o','o']

a[1] = 0
b[1] = 0
// a: 'foo'
// b: ['f', 0, 'o']

// 字符串不可变是指字符串的成员不会改变其原始值，而是创建并返回一个新的字符串。而数组的成员都是在其原始值上进行操作
c = a.toUpperCase()
a === c // false
// a: 'foo'
// c: 'FOO'

b.push('!') // 4，会返回一个长度
// b: ['f', 0, 'o', '!']

// 许多数组函数用来处理字符串很方便，虽然字符串没有这些函数，但是可以通过“借用”数组的非变更方法来处理字符串

a.join undefined
a.map  undefined

var a1 = Array.prototype.join.call(a, '-')
// a1: 'f-o-o'
var a2 = Array.prototype.map.call(a, function(item) {
  return item.toUpperCase() + '.'
}).join('')
// a2: 'F.O.O.'

// 另外一个不同点在于字符串反转（js常见面试题），数组有一个字符串没有的可变更函数 reverse()
a.reverse undefined
b.reverse()
// b.reverse(): ['!', 'o', 0, 'f']
// b:           ['!', 'o', 0, 'f']

// 可惜我们无法“借用”数组的可变更函数，因为字符串是不可变的。一个变通的方法是先将字符串转换为数组，待处理完后再将结果转换回字符串，这种方法只对简单的字符串有效，对于包含复杂字符（Unicode，如星号、多字节字符等的字符并不适用，这时则需要功能更加完备、能够处理Unicode的工具库）

var a3 = a
// 先将a的值转换为字符数组
        .split('')
// 在将数组中的字符进行倒转
        .reverse()
// 最后将水准中的字符拼接回字符串
        .join('')
// a3: 'oof'
```