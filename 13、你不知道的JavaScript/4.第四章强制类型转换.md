# 值类型转换

```js
// 将值从一种类型转换为另一种类型通常称为类型转换，这是显示的情况；（也可称呼为显示强制类型转换）【能够从代码中看出哪些地方是显示强制类型转换】
// 隐式的情况称为强制类型转换。（也可称呼为隐式强制类型转换）【不那么明显，通常是某些操作产生的副作用】

var a = 42
var b = a + '' // 隐式强制类型转换
var c = String(a) // 显式强制类型转换
```

# 字符串、数字和布尔值之间类型转换的基本规则

## ToString()

```js
// 处理非字符串到字符串的强制类型转换
// 基本类型值的字符串化规则为：
null.toString() // 'null'
undefined.toString() // 'undefined'
true.toString() // ’true‘

// 对普通对象来说，除非自行定义，否则 toString() [Object.prototype.toString()]返回内部属性[[Class]]的值，如[object Object]，然而，如果对象有自己的toString()方法，字符串化时就会调用该方法并使用其返回值

// 数组的默认 toString() 方法经过了重新定义，将所有单元字符串化以后再用","【英文逗号】连接起来：
var a = [1, 2, 3]
a.toString() // '1,2,3'

// JSON字符串化
// JSON.stringify() 在将JSON对象序列化为字符串时也用到了 toString()
// 对于简单值来说，JSON字符串化和 toString() 的效果基本相同，只不过序列化的结果总是字符串:
JSON.stringify(42) // '42'
JSON.stringify('42') // ''42''
JSON.stringify(null) // 'null'

// 所有安全的JSON值（JSON-safe）都可以使用 JSON.stringify() 字符串化，安全的JSON值是指能够呈现为有效JSON格式的值
// 不安全的JSON值：undefined、function、symbol和包含循环引用（对象之间相互引用，形成一个无限循环）的对象都不符合JSON结构标准
// JSON.stringify() 在对象中遇到 undefined、function、symbol时会自动将其忽略，在数组中会返回null（以保证单元位置不变）
// 如果对象中定义了 toJSON() 方法，JSON字符串化时会首先调用该方法，然后用它的返回值来进行序列化（如果要对含有非法JSON值的对象做字符串化，或者对象中的某些值无法被序列化时，就需要定义 toJSON() 方法来返回一个安全的JSON值）
```

## ToNumber()

```js
// 有时我们需要将非数字值当作数字来使用，比如数学运算。
// 其中 true 转换为1，false 转换为0。undefined 转换为NaN，null 转换为0。

// ToNumber()对字符串的处理基本遵循数字常量的相关规则/语法。处理失败时返回NaN。不同之处是ToNumber()对以0开头的八进制数并不按八进制处理（而是按十进制）
```

## ToBoolean()

```js
// 假值：undefined、null、false、+0，-0和NaN、""（假值的布尔强制类型转换结果为false）
// 真值：假值列表以外的值都是真值
```

# 字符串和数字之间的显示转换

```js
// 日期显示转换为数字
var timestamp1 = +new Date() // 当前的时间戳，将日期对象强制类型转换为数字【不建议对日期类型使用强制类型转换】
var timestamp2 = new Date().getTime() // 更显示的方法，传递相关参数可以获得指定时间对时间戳
var timestamp3 = Date.now() // es5中新加入的静态方法
```

## 显示解析数字字符串

```js
// 解析字符串中的数字、将字符串强制类型转换为数字的返回结果都是数字，但解析和转换两者之间还是有明显的区别

var a = '42'
var b = '42px'

// 解析【允许字符串中含有非数字字符，解析从左到右的顺序，如果遇到非数字字符就停止】
parseInt(a) // 42
parseInt(b) // 42

// 转换【不允许出现非数字字符，否则会失败并返回NaN】
Number(a) // 42
Number(b) // NaN

// 解析和转换之间不是相互替代的关系，它们虽然类似，但各有各的用途。如果字符串右边的非数字字符不影响结果，就可以使用解析。而转换要求字符串中所有的字符都是数字，像'42px'这样的字符串就不行。

// https://cloud.tencent.com/developer/article/1743717
// parseInt() 针对的是字符串值，向其中传递数字和其它类型的参数是没有用的，比如 true、function() {}、[1,2,3]，非字符串参数会首先被强制类型转换为字符串，依赖这样的隐式强制类型转换并非上策，应该避免向 parseInt() 传递非字符串参数。

/* es6之前的 parseInt() 有一个坑导致了很多bug，即如果没有第二个参数来制定转换的基数（又称为radix），该函数会根据字符串的第一个字符来自行决定基数。
如果第一个字符是x或者X，则转换为16进制数字；如果是0，则转换为8进制数字
导致的问题就是当参数为 08、09 的时候，结果就分别都是 0、0。
将第二个参数设置为 10，即可避免这个问题。
*/

/**
 * 在实际的js代码中不会用到基数19，它的有效数字字符范围是0～9和a~i（区分大小写）
 */
parseInt(1/0， 19) // 18
```

## 显示转换为布尔值

```js
// 虽然 Boolean() 是显示的，但并不常用，显示强制类型转换为布尔值最常用的方法是 !!。
// 在 if(...) {...} 这样的布尔值上下文中，如果没有使用 Boolean()和!!，就会自动隐式地进行 toBoolean() 转换，建议使用 Boolean()和!!来显示转换以便让代码更清晰易读。

var a = 42
var b = a ? true : false

// 表面上这是一个显示的 toBoolean() 强制类型转换，因为返回结果是true或false。然而这里涉及到隐式强制类型转换，因为a首先要被强制类型转换为布尔值才能进行条件判断，这种情况称为“显式的隐式”，有百害而无一益，我们应该彻底杜绝！建议使用 Boolean(a) 和 !!a 来进行显式强制类型转换。
```

# 字符串和数字之间的隐式转换

```js
// 隐式强制类型转换指的是那些隐蔽的强制类型转换，副作用也不是很明显换句话说，你自己觉得不够明显的强制类型转换都可以算作隐式强制类型转换。隐式强制类型转换的作用是减少冗余，让代码更简洁。
```

## 字符串和数字之间的隐式强制类型转换

```js
var a = '42'
var b = '0'

var c = 42
var d = 0

// a + b '420'
// c + d 42
// 理解：因为某一个或者两个操作数都是字符串，所以+执行的是字符串拼接

var e = [1, 2]
var f = [3, 4]

// e + f '1,23,4'
// 理解：e和f都不是字符串，但是他们都被强制转换为字符串然后进行拼接
/*
根据es5规范，如果某个操作数是自负还或者能够通过以下步骤转换为字符串的话，+将进行拼接操作。
如果其中一个操作数是对象（包括数组），则首先对其调用 ToPrimitive 抽象操作，该抽象操作再调用 [[DefaultValue]]，以数字作为上下文
*/
// 你或许注意到这与 ToNumber 抽象操作处理对象的方式一样，因为数字的 valueOf() 操作无法得到简单基本类型值，于是它转而调用 toString()。因此上例中的两个数组变成了 '1,2'和'1,23,4'。简单来说就是，如果+的其中一个操作数是字符串（或者通过以上步骤可以得到字符串），则执行字符串拼接，否则执行数字加法。

// 对隐式强制类型转换来说，这意味着什么？
// 我们可以将数字和空字符串 '' 相 + 来将其转换为字符串：
var a = 42
var b = a + ''
// b '42'

// + 作为数字加法操作是可互换的，即 2+3 等同于 3+2。作为字符串拼接操作则不行，但对空字符串 '' 来说，a+'' 和 ''+a 结果一样

var a = {
  valueOf: function () {
    return 42
  },
  toString: function () {
    return 4
  },
}

// a + '' '42' 根据 ToPrimitive 抽象操作规则，会对 a 调用valueOf()方法，然后通过toString()方法将返回值转换为字符串。
// String(a) 4 直接调用toString()方法

// 字符串转换为数字
var a = '3.14'
var b = a - 0
// b 3.14

// - 是数字减法运算符，因此 a-0 会将a强制类型转换为数字。也可以使用 a*1 和 a/1，因为这两个运算符也只适用于数字，只不过这样的用法不常见
// 对象的 - 操作和 + 类似
var a = [3]
var b = [1]
// a - b 2
// 为了执行减法运算，a和b都需要被转换为数字，它们首先被转换为字符串（toString()），然后再转换为数字。

b = String(a) // 显式
b = a + '' // 隐式（更常见）
```

## 布尔值到数字的隐式强制类型转换

```js
// 在将某些复杂的布尔逻辑转换为数字加法的时候，隐式强制类型转换能派上大用场。
// 写一个函数：需要满足当其中有且仅有一个参数为true返回tru.

function onlyOne(a, b, c) {
  return Boolean((a && !b && !c) || (!a && b && !c) || (!a && !b && c))
}
// 上述函数在条件判断中使用了隐式强制类型转换，其它地方则是显示的，包括最后的返回值。

// 但当有多个参数时（4，5甚至20个），用上面的代码就很难处理了。这时候就可以利用从布尔值到数字（0或者1）的强制类型转换
function onlyOne(...args) {
  let temp = 0
  args.forEach((item) => {
    if (item) {
      // temp = temp + item
      // 如果是非布尔值参数需要处理下
      temp = temp + Number(!!item)
    }
  })
  return temp === 1
}

// 也可以使用reduce
function onlyOne(...args) {
  let sum = 0
  sum = args.reduce((prev, cur) => prev + cur)
  return sum === 1
}
```

## 隐式强制类型转换为布尔值

```js
// 相对布尔值，数字和字符串操作中的隐式强制类型转换还算比较明显，下面的情况会发生布尔值隐式强制类型转换。
/**
 * （1）if() 语句中的条件判断表达式
 * （2）for(exp1;exp2;exp3) 语句中的条件判断表达式（exp2）
 * （3）while(exp) 和 do .. while(..) 循环中的条件判断表达式
 * （4）? : 中的条件判断表达式
 * （5）逻辑运算符 ||(逻辑或) 和 &&(逻辑与)左边的操作数(作为条件判断表达式)
 */
// 遵循 ToBoolean() 抽象操作规则
```

## ||和&&

```js
// "逻辑运算符"应该被称为"选择器运算符"，因为它和其他语言不同，在js中它们返回的并不是布尔值。
// 它们的返回值是两个操作数中的一个（且仅一个）。即选择两个操作数中的一个，然后返回它的值。

/**
 * js代码压缩工具常用：就是如果第一个操作数为真值，则&&运算符"选择"第二个操作数作为返回值，这也叫做"守护运算符"，即前面的表达式为后面的表达式"把关"
 * function foo() { console.log(a) }
 * var a = 42
 * a && foo() // 42
 * 开发人员通常使用 if(a) { foo() }，但js代码压缩工具用的是 a && foo()，因为更简洁
 */
```

## 宽松相等和严格相等

```js
//  宽松相等（loose equals）== 和 严格相等（strict equals）=== 都用来判断两个值是否“相等”
// 常见的误区是：==检查值是否相等，===检查值和类型是否相等，还不够准确
// 正确的解释是：==允许在相等比较中进行强制类型转换，===不允许
```

## 抽象相等 == 

```js
/**
 * 1.字符串和数字之间的相等比较：
 *（1）如果 Type(x) 是数字，Type(y) 是字符串，则返回 x == ToNumber(y) 的结果
 *（2）如果 Type(x) 是字符串，Type(y) 是数字，则返回 ToNumber(x) == y 的结果
 */

```