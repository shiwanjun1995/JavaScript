# 值类型转换

```js
// 将值从一种类型转换为另一种类型通常称为类型转换，这是显示的情况；（也可称呼为显示强制类型转换）【能够从代码中看出哪些地方是显示强制类型转换】
// 隐式的情况称为强制类型转换。（也可称呼为隐式强制类型转换）【不那么明显，通常是某些操作产生的副作用】

var a = 42
var b = a + '' // 隐式强制类型转换
var c = String(a) // 显式强制类型转换
```

# 字符串、数字和布尔值之间类型转换的基本规则

## toString()

```js
// 处理非字符串到字符串的强制类型转换
// 基本类型值的字符串化规则为：
null.toString() // 'null'
undefined.toString() // 'undefined'
true.toString() // ’true‘

// 对普通对象来说，除非自行定义，否则 toString() [Object.prototype.toString()]返回内部属性[[Class]]的值，如[object Object]，然而，如果对象有自己的toString()方法，字符串化时就会调用该方法并使用其返回值

// 数组的默认 toString() 方法经过了重新定义，将所有单元字符串化以后再用","【英文逗号】连接起来：
var a = [1, 2, 3]
a.toString() // '1,2,3'

// JSON字符串化
// JSON.stringify() 在将JSON对象序列化为字符串时也用到了 toString()
// 对于简单值来说，JSON字符串化和 toString() 的效果基本相同，只不过序列化的结果总是字符串:
JSON.stringify(42) // '42'
JSON.stringify('42') // ''42''
JSON.stringify(null) // 'null'

// 所有安全的JSON值（JSON-safe）都可以使用 JSON.stringify() 字符串化，安全的JSON值是指能够呈现为有效JSON格式的值
// 不安全的JSON值：undefined、function、symbol和包含循环引用（对象之间相互引用，形成一个无限循环）的对象都不符合JSON结构标准
// JSON.stringify() 在对象中遇到 undefined、function、symbol时会自动将其忽略，在数组中会返回null（以保证单元位置不变）
// 如果对象中定义了 toJSON() 方法，JSON字符串化时会首先调用该方法，然后用它的返回值来进行序列化（如果要对含有非法JSON值的对象做字符串化，或者对象中的某些值无法被序列化时，就需要定义 toJSON() 方法来返回一个安全的JSON值）
```

## toNumber()

```js
// 有时我们需要将非数字值当作数字来使用，比如数学运算。
// 其中 true 转换为1，false 转换为0。undefined 转换为NaN，null 转换为0。

// toNumber()对字符串的处理基本遵循数字常量的相关规则/语法。处理失败时返回NaN。不同之处是toNumber()对以0开头的八进制数并不按八进制处理（而是按十进制）
```

## toBoolean()

```js
// 假值：undefined、null、false、+0，-0和NaN、""（假值的布尔强制类型转换结果为false）
// 真值：假值列表以外的值都是真值
```

# 字符串和数字之间的显示转换

```js
// 日期显示转换为数字
var timestamp1 = +new Date() // 当前的时间戳，将日期对象强制类型转换为数字【不建议对日期类型使用强制类型转换】
var timestamp2 = new Date().getTime() // 更显示的方法，传递相关参数可以获得指定时间对时间戳
var timestamp3 = Date.now() // es5中新加入的静态方法
```

# 显示解析数字字符串

```js
// 解析字符串中的数字、将字符串强制类型转换为数字的返回结果都是数字，但解析和转换两者之间还是有明显的区别

var a = '42'
var b = '42px'

// 解析【允许字符串中含有非数字字符，解析从左到右的顺序，如果遇到非数字字符就停止】
parseInt(a) // 42
parseInt(b) // 42

// 转换【不允许出现非数字字符，否则会失败并返回NaN】
Number(a) // 42
Number(b) // NaN

// 解析和转换之间不是相互替代的关系，它们虽然类似，但各有各的用途。如果字符串右边的非数字字符不影响结果，就可以使用解析。而转换要求字符串中所有的字符都是数字，像'42px'这样的字符串就不行。

// https://cloud.tencent.com/developer/article/1743717
// parseInt() 针对的是字符串值，向其中传递数字和其它类型的参数是没有用的，比如 true、function() {}、[1,2,3]，非字符串参数会首先被强制类型转换为字符串，依赖这样的隐式强制类型转换并非上策，应该避免向 parseInt() 传递非字符串参数。

/* es6之前的 parseInt() 有一个坑导致了很多bug，即如果没有第二个参数来制定转换的基数（又称为radix），该函数会根据字符串的第一个字符来自行决定基数。
如果第一个字符是x或者X，则转换为16进制数字；如果是0，则转换为8进制数字
导致的问题就是当参数为 08、09 的时候，结果就分别都是 0、0。
将第二个参数设置为 10，即可避免这个问题。
*/

/**
 * 在实际的js代码中不会用到基数19，它的有效数字字符范围是0～9和a~i（区分大小写）
 */
parseInt(1/0， 19) // 18
```

# 显示转换为布尔值

```js
// 虽然 Boolean() 是显示的，但并不常用，显示强制类型转换为布尔值最常用的方法是 !!。
// 在 if(...) {...} 这样的布尔值上下文中，如果没有使用 Boolean()和!!，就会自动隐式地进行 toBoolean() 转换，建议使用 Boolean()和!!来显示转换以便让代码更清晰易读。

var a = 42
var b = a ? true : false

// 表面上这是一个显示的 toBoolean() 强制类型转换，因为返回结果是true或false。然而这里涉及到隐式强制类型转换，因为a首先要被强制类型转换为布尔值才能进行条件判断，这种情况称为“显式的隐式”，有百害而无一益，我们应该彻底杜绝！建议使用 Boolean(a) 和 !!a 来进行显式强制类型转换。
```
